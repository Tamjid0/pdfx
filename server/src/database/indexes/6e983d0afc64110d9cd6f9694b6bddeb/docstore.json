[[["9508911d-7fac-44ed-b644-ad1fd1b95e54",{"pageContent":"CSE106 Discrete Mathematics - Complete Lesson Part 1: COUNTING 1.1 Basic Counting Principles Product Rule If a procedure has two tasks where: Task 1 can be done in n₁ ways Task 2 can be done in n₂ ways (after task 1) Then the procedure can be done in n₁ × n₂ ways. Example 1: How many 7-bit strings exist? Each bit has 2 choices (0 or 1) Total = 2 × 2 × 2 × 2 × 2 × 2 × 2 = 2⁷ = 128 Example 2: A company assigns offices to 2 employees from 12 available offices. First employee: 12 ways Second employee: 11 ways (one office taken) Total = 12 × 11 = 132 ways Sum Rule If tasks cannot be done simultaneously: Task 1: n₁ ways Task 2: n₂ ways Then one of these tasks can be done in n₁ + n₂ ways. Example 3: Choose a representative from 37 faculty or 83 students. Total = 37 + 83 = 120 ways 1.2 Complex Counting Problems Example 4: Password with 6-8 characters (uppercase letters or digits), must have at least one digit. 6-char passwords: 36⁶ - 26⁶ = 1,867,866,560 7-char passwords: 36⁷ - 26⁷ =","metadata":{"loc":{"lines":{"from":1,"to":1}}}}],["c8551bb1-c83f-4dbd-ab9a-eb6a755cf611",{"pageContent":"have at least one digit. 6-char passwords: 36⁶ - 26⁶ = 1,867,866,560 7-char passwords: 36⁷ - 26⁷ = 70,332,353,920 8-char passwords: 36⁸ - 26⁸ = 2,612,282,842,880 Total = 2,684,483,063,360 1.3 Inclusion-Exclusion Principle For overlapping tasks: |A ∪ B| = |A| + |B| - |A ∩ B| Example 5: 8-bit strings starting with 1 OR ending with 00. Start with 1: 2⁷ = 128 End with 00: 2⁶ = 64 Both: 2⁵ = 32 Total = 128 + 64 - 32 = 160 1.4 Pigeonhole Principle Basic: If k+1 objects are placed in k boxes, at least one box contains ≥2 objects. Generalized: If N objects in k boxes, at least one box contains ⌈ N/k ⌉ objects. Example 6: Among 367 people, at least 2 share a birthday (366 possible days). Example 7: Minimum students needed so 6 get the same grade (5 possible grades A-F)? Formula: N = k(r-1) + 1 N = 5(6-1) + 1 = 26 students Part 2: ALGORITHMS 2.1 Algorithm Basics Definition: A finite set of precise instructions for computation or problem-solving. Example 8: Maximum Element Algorithm 2.2","metadata":{"loc":{"lines":{"from":1,"to":1}}}}],["fcf3888e-b7c6-400f-8fe6-6a0b7fa67d3c",{"pageContent":"precise instructions for computation or problem-solving. Example 8: Maximum Element Algorithm 2.2 Searching Algorithms Linear Search Check each element sequentially Time Complexity: O(n) Worst case: 2n + 2 comparisons Binary Search (for sorted lists) Divide search space in half each iteration Time Complexity: O(log n) Comparisons: 2log₂n + 2 Example 9: Search for 19 in sorted list [1,2,3,5,6,7,8,10,12,13,15,16,18,19,20,22] 1. Middle index 8: value=10, 19>10 → search right half 2. Middle index 12: value=16, 19>16 → search right half 3. Middle index 14: value=19 ✓ Found at position 14 2.3 Big-O Notation Definition: f(x) = O(g(x)) if ∃ constants C, k such that f(x) ≤ Cg(x) for x ≥ k. Common Orders (smallest to largest): 1, log n, n, n log n, n², n³, 2ⁿ, n! Example 10: Show f(x) = x² + 2x + 1 = O(x²) f(x) ≤ x² + 2x² + x² = 4x² (for x ≥ 1) Witnesses: C = 4, k = 1 Example 11: Estimate 3n log(n!) + (n² + 3)log n procedure max(a₁, a₂, ..., aₙ: integers) procedure max(a₁, a₂, ..., aₙ:","metadata":{"loc":{"lines":{"from":1,"to":1}}}}],["711f8982-6bb6-42e1-b688-1dc84fd3d6ea",{"pageContent":"3n log(n!) + (n² + 3)log n procedure max(a₁, a₂, ..., aₙ: integers) procedure max(a₁, a₂, ..., aₙ: integers) max := a₁ max := a₁ for i := 2 to n for i := 2 to n if max < aᵢ then max := aᵢ if max < aᵢ then max := aᵢ return max return max 3n = O(n) log(n!) = O(n log n) 3n log(n!) = O(n² log n) (n² + 3)log n = O(n² log n) Result: O(n² log n) 2.4 Algorithm Complexity Example 12: Maximum Element Loop executes (n-1) times 2 comparisons per iteration + 1 final Total: 2(n-1) + 1 = 2n - 1 Complexity: Θ(n) Example 13: Linear Search (worst case) Element not in list or at end Comparisons: 2n + 2 Complexity: O(n) Example 14: Binary Search Each iteration halves the search space Comparisons: 2log₂n + 2 Complexity: Θ(log n) Part 3: GRAPHS 3.1 Graph Basics Definition: G = (V, E) where V = vertices, E = edges. Types: Undirected: Edges have no direction Directed (Digraph): Edges have direction (u→v) Mixed: Both directed and undirected edges 3.2 Graph Terminology Degree: Number of edges incident with a","metadata":{"loc":{"lines":{"from":1,"to":1}}}}],["9063d519-2fe0-4de2-91fc-7a18ccb98a52",{"pageContent":"Both directed and undirected edges 3.2 Graph Terminology Degree: Number of edges incident with a vertex (loops count twice) Handshaking Theorem: 2|E| = Σ deg(v) Example 15: Graph with 10 vertices, each degree 6. How many edges? Sum of degrees = 6 × 10 = 60 2|E| = 60 |E| = 30 edges For Directed Graphs: In-degree (deg⁻): Edges ending at v Out-degree (deg⁺): Edges starting from v Theorem: Σ deg⁻(v) = Σ deg⁺(v) = |E| 3.3 Special Graphs Complete Graph Kₙ n vertices, every pair connected Edges = n(n-1)/2 Cycle Cₙ n vertices in a circle n edges Wheel Wₙ Cycle Cₙ plus center vertex n+1 vertices, 2n edges Bipartite Graph Vertices split into two disjoint sets V₁, V₂ All edges connect V₁ to V₂ (no edges within same set) Example 16: Is K₃ bipartite? No, because we can't partition 3 vertices into two sets where no edges exist within sets 3.4 Graph Representation Adjacency Matrix n×n matrix A where A[i,j] = 1 if edge exists, 0 otherwise For undirected: symmetric matrix For directed: not necessarily","metadata":{"loc":{"lines":{"from":1,"to":1}}}}],["7185a8ac-4f51-4b8f-85bb-79a800cd1938",{"pageContent":"= 1 if edge exists, 0 otherwise For undirected: symmetric matrix For directed: not necessarily symmetric Example 17: Graph with vertices {a,b,c,d} and edges {ab, ac, bd, cd} Adjacency List List each vertex with its neighbors Space efficient for sparse graphs Part 4: TREES 4.1 Tree Basics Definition: A connected undirected graph with no simple circuits. Theorem: A tree with n vertices has exactly n-1 edges . Theorem: There's a unique simple path between any two vertices in a tree. Example 18: Is the following a tree? a b c d a b c d a [ 0 1 1 0 ] a [ 0 1 1 0 ] b [ 1 0 0 1 ] b [ 1 0 0 1 ] c [ 1 0 0 1 ] c [ 1 0 0 1 ] d [ 0 1 1 0 ] d [ 0 1 1 0 ] Graph with vertices {a,b,c,d,e} and edges {ab, bc, cd, de} Connected? Yes Circuits? No Yes, it's a tree 4.2 Rooted Trees Definition: Tree with designated root vertex, edges directed away from root. Terminology: Parent: Vertex directly above Child: Vertex directly below Siblings: Vertices with same parent Ancestors: All vertices on path to root","metadata":{"loc":{"lines":{"from":1,"to":1}}}}],["2d83ae60-d7c6-4f5e-b50f-5f3ec8d56c7a",{"pageContent":"Vertex directly below Siblings: Vertices with same parent Ancestors: All vertices on path to root Descendants: All vertices in subtree below Leaf: Vertex with no children (degree 1 in tree) Internal vertex: Vertex with children Level: Distance from root (root is level 0) Height: Maximum level in tree Example 19: In rooted tree with structure: Parent of e: b Children of b: d, e Siblings of d: e Leaves: d, e, f Internal vertices: a, b, c Level of d: 2 a (root) a (root) / \\ / \\ b c b c /| | /| | d e f d e f Height: 2 4.3 M-ary Trees Definition: Every internal vertex has ≤ m children. Full m-ary tree: Every internal vertex has exactly m children. Binary tree: m = 2 Theorems for Full m-ary Trees: 1. n = mi + 1 (n vertices, i internal vertices) 2. With n vertices: i = (n-1)/m internal vertices l = [(m-1)n + 1]/m leaves 3. With i internal vertices: n = mi + 1 vertices l = (m-1)i + 1 leaves 4. With l leaves: n = (ml-1)/(m-1) vertices i = (l-1)/(m-1) internal vertices Example 20: Full 3-ary","metadata":{"loc":{"lines":{"from":1,"to":1}}}}],["5a2873d9-c4ad-4312-b9c7-e13dc911cf53",{"pageContent":"With l leaves: n = (ml-1)/(m-1) vertices i = (l-1)/(m-1) internal vertices Example 20: Full 3-ary tree with 13 vertices. m = 3, n = 13 Internal vertices: i = (13-1)/3 = 4 Leaves: l = [(3-1)×13 + 1]/3 = 27/3 = 9 Edges: e = n-1 = 12 Example 21: Full binary tree with 15 leaves. Find total vertices. m = 2, l = 15 n = (2×15 - 1)/(2-1) = 29/1 = 29 vertices i = (15-1)/(2-1) = 14 internal vertices 4.4 Balanced Trees Definition: All leaves are at levels h or h-1 (where h = height). Importance: Balanced trees ensure efficient operations (O(log n) time). Example 22: Determine if trees are balanced: Tree 1: Leaves at levels 3,3,3,3,4,4 → Balanced Tree 2: Leaves at levels 2,3,3,4,4,4 → Not balanced (levels differ by >1) 4.5 Binary Tree Specifics Ordered Binary Tree: Left child: First child Right child: Second child Left subtree: Tree rooted at left child Right subtree: Tree rooted at right child Maximum Nodes in Binary Tree of Height h: Full tree: 2^(h+1) - 1 nodes Minimum nodes (balanced): h + 1","metadata":{"loc":{"lines":{"from":1,"to":1}}}}],["39f49184-9cba-46fe-a926-31bb9b19e0f6",{"pageContent":"Nodes in Binary Tree of Height h: Full tree: 2^(h+1) - 1 nodes Minimum nodes (balanced): h + 1 nodes PRACTICE PROBLEMS Problem 1: Counting How many 4-digit passwords use digits 0-9, start with even digit, end with odd digit? First position (even): 5 choices (0,2,4,6,8) Middle two: 10 choices each Last position (odd): 5 choices (1,3,5,7,9) Answer: 5 × 10 × 10 × 5 = 2,500 Problem 2: Pigeonhole Prove: In any set of 13 integers, at least 2 have the same remainder when divided by 12. 12 possible remainders (0-11) 13 integers → By pigeonhole principle, at least ⌈ 13/12 ⌉ = 2 must share a remainder Problem 3: Big-O Find Big-O for f(n) = 5n³ + 2n² log n + 8n 5n³ = O(n³) 2n² log n = O(n² log n) 8n = O(n) f(n) = O(n³) (largest term dominates) Problem 4: Graph A graph has 8 vertices with degrees: 3,3,3,3,4,4,5,5. How many edges? Sum = 3+3+3+3+4+4+5+5 = 30 2|E| = 30 |E| = 15 edges Problem 5: Tree A full 5-ary tree has 101 leaves. Find total vertices. m = 5, l = 101 n = (5×101 - 1)/(5-1) = 504/4 =","metadata":{"loc":{"lines":{"from":1,"to":1}}}}],["b91656a0-f407-4688-ad1b-39f965efe5f5",{"pageContent":"full 5-ary tree has 101 leaves. Find total vertices. m = 5, l = 101 n = (5×101 - 1)/(5-1) = 504/4 = 126 vertices i = (101-1)/(5-1) = 100/4 = 25 internal vertices KEY FORMULAS SUMMARY Counting: Product Rule: n₁ × n₂ × ... × nₖ Sum Rule: n₁ + n₂ + ... + nₖ Pigeonhole: N objects in k boxes → at least ⌈ N/k ⌉ in one box Graphs: Handshaking: 2|E| = Σ deg(v) Complete graph edges: n(n-1)/2 Tree edges: n-1 Trees: Full m-ary: n = mi + 1 Leaves: l = (m-1)i + 1 Height of balanced binary tree: ⌈ log₂(n+1) ⌉ - 1 Complexity: Linear: O(n) Logarithmic: O(log n) Quadratic: O(n²) Exponential: O(2ⁿ) End of Lesson","metadata":{"loc":{"lines":{"from":1,"to":1}}}}]],{"0":"9508911d-7fac-44ed-b644-ad1fd1b95e54","1":"c8551bb1-c83f-4dbd-ab9a-eb6a755cf611","2":"fcf3888e-b7c6-400f-8fe6-6a0b7fa67d3c","3":"711f8982-6bb6-42e1-b688-1dc84fd3d6ea","4":"9063d519-2fe0-4de2-91fc-7a18ccb98a52","5":"7185a8ac-4f51-4b8f-85bb-79a800cd1938","6":"2d83ae60-d7c6-4f5e-b50f-5f3ec8d56c7a","7":"5a2873d9-c4ad-4312-b9c7-e13dc911cf53","8":"39f49184-9cba-46fe-a926-31bb9b19e0f6","9":"b91656a0-f407-4688-ad1b-39f965efe5f5"}]